# Регламент проверки безопасности контрактов Airalab
## Обобщенные рекомендации к проверке
- Избегайте внешних вызовов когда это возможно, очень часто они являются причиной уязвимости
- Отдавайте приоритет изменению состояния над внешним вызовом вызовом (включая `.send()`)
- Изолируйте внешние вызовы в отдельной транзакции, например, метод `withdraw` для вывода средств
- Будте внимательны при делении целых чисел (округление происходит к ближайшему целому)
- При делении на ноль возвращается **ноль**, проверяйте аргументы самостоятельно
- Будте внимательны к переполнению целых чисел (особенно в сравнениях) и приведению знаковых к беззнаковым в JS
- Будте осторожны с привязкой логики контракта ко времени блока, оно устанавливается майнером
- Подумайте о способе обновления контракта в будующем
- Используйте метки остановки работы контракта в случае чрезвычайной ситуации, например обнаружении уязвимости
- Разделяйте критически важные вызовы во времени, например, вывод большого количества средств не чаще раза в неделю
- Используйте [формальную верификацию](https://gist.github.com/chriseth/c4a53f201cd17fc3dd5f8ddea2aa3ff9) контрактов

## Известные атаки
### Атака по глубине стека
**Идея:** разрешенная глубина стека составляет 1024, вызовы глубже не быдут выполнены, однако транзакция не прервется; атакующий может вызвать код с глубиной стека 1023, в таком случае вызовы из уязвимого кода, например `send()` не будут исполнены.

```
// INSECURE
contract auction {
    mapping(address => uint) refunds;

    // [...]

    function withdrawRefund(address recipient) {
        uint refund = refunds[recipient];
        refunds[recipient] = 0;
        recipient.send(refund); // эта строка исполнится не так, как ожидается
    }
}
```

**Противодействие:** минимизация вызовов внутри методов, приоритет записи и учета над вызовом другого метода; а также `.send()` возвращает `false` если не может быть исполнена, необходимо при каждой отправке средств проверять возвращаемое значение.

### Условия гонки
**Идея:** внешний вызов может произвести неконтролируемые изменения в данных контракта.

```
// INSECURE
mapping (address => uint) private userBalances;

function withdrawBalance() public {
    uint amountToWithdraw = userBalances[msg.sender];
    // в этом месте внешний контракт может вызвать метод withdrawBalance снова
    if (!(msg.sender.call.value(amountToWithdraw)())) { throw; }
    userBalances[msg.sender] = 0;
}
```

**Противодействие:** для недоверенного кода(`msg.sender`) приоритет в использовании `.send()` над `.call.value()`, так как количество газа для `.send()` очень ограничено и не может быть использовано для эксплуатации уязвимости.

### DoS при вызове исключения
**Идея:** работа контракта может быть заблокирована брокском исключения во внешнем вызываемом коде.

```
// INSECURE
contract Auction {
    address currentLeader;
    uint highestBid;

    function bid() {
        if (msg.value <= highestBid) { throw; }

        // если контракт в fallback вызовет исключение, новый лидер не сможет быть назначен
        if (!currentLeader.send(highestBid)) { throw; }

        currentLeader = msg.sender;
        highestBid = msg.value;
    }
}
```

**Противодействие:** приоритет логирования и записи во внутренние структуры над непосредственной отправкой, например, введение вызова `withdraw` для доступа к вознаграждению из текущего примера.

### DoS при переполнении лимита газа
**Идея:** объем газа в блоке ограничен, если для транзакции требуется газа больше, чем помещается в блок - она никогда не будет исполнена.

```
struct Payee {
    address addr;
    uint256 value;
}
Payee payees[];
uint256 nextPayeeIndex;

function payOut() {
    uint256 i = 0;
    // при достаточно большом размере payees возможно превысить лимит газа
    while (i < payees.length) {
        payees[i].addr.send(payees[i].value);
        i++;
    }
}
```
**Противодействие:** избегать итерации по большим массивам данных, либо переносить перебор на программную логику вне контракта; если невозможно избавиться от перебора, необходимо разбить его на несколько шагов, либо выполнять действия по запросу, например, добавить метод `withdraw` для вывода средств.

## Ссылки
1. [Ethereum Contract Security Techniques and Tips]((https://github.com/ConsenSys/smart-contract-best-practices))
2. [Публикация в блоге Ethereum Christian Reitwiessner: Smart contract security](https://blog.ethereum.org/2016/06/10/smart-contract-security/)
3. [Публикация в блоге Ethereum Виталика Бутерина: Thinking About Smart Contract Security](https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/)
4. [Запись лекции по безопасности умных контрактов на Youtube: Smart contract security in Ethereum](https://www.youtube.com/watch?v=pv032ppbakA)
5. [Smart Contract Security in Ethereum](https://docs.google.com/presentation/d/1kS9mVOQNieloYByGQw3P-Yyup2BYE5tg7jOItMNnR0A/edit#slide=id.g15d26d8dbd_0_0)
