import 'token/TokenEmission.sol';
import 'common/Mortal.sol';

/**
  @title Token ἄμβιξ

           .                                       
          C..1                                      
           fL                                       
          GLi11                                     
          if i11t11:                                
         ,.t. .  ;,:1i,t                            
       .,:i  .:1f..,  .,:i:1                        
      i.1f.  .    ,f .ftt...,i;;                    
     i.11 . . .   . ,     .f11..,i1:                
     ,,1,   .     .  1         .ft1 ,11.            
     :1Lf:::, ,,,,,..:              .tf;,:i.        
     fCCCLffL ittCCCff                    Lf;1t     
    .iGCCCLttLftCCCCCi.                       ,:    
      t,GGGCCCLLCCGC                        ;i;1i:  
     ,;  :ftttiit.::,                      Litf1fft1
     L       GC    LC                      1,. .. t,
    C        ;t    1.;                     t,.....1,
   t:        ;t     fC.11.                 1ti;;:;1,
  ;ftti1t1tfCLGfCCLCCfL1ft1i1i1t1fftfffftffCGCfttCC,
  ,i11ii;1;tC;CCCL1t1ft111t1tittii1i11i1ii;111LCLCC,

  @dev Ambix contract is used for morph Token set to another
  Token's by rule (recipe). In distillation process given
  Token's are burned and result generated by emission.
  
  The recipe resented as equation in form:
  (N1 * A1 | N'1 * A'1 | N''1 * A''1 ...)
  & (N2 * A2 | N'2 * A'2 | N''2 * A''2 ...) ...
  & (Nn * An | N'n * A'n | N''n * A''n ...)
  = M1 * B1 & M2 * B2 ... & Mm * Bm 
    where A, B - input and output tokens
          N, M - token value coeficients
          n, m - input / output dimetion size 
          | - is alternative operator (logical OR)
          & - is associative operator (logical AND)
  This says that `Ambix` should receive (approve) left
  part of equation and send (transfer) right part.
*/
contract Ambix is Mortal {
    struct Recipe {
        TokenEmission[][] source;
        uint[][]          sourceCoef;
        TokenEmission[]   sink;
        uint[]            sinkCoef;
    }
    Recipe recipe;

    /**
     * @dev Set source by index
     * @param _index is a source index
     * @param _source is a list of source alternatives
     * @param _coef is a list of source alternatives coeficients
     */
    function setSource(uint _index, TokenEmission[] _source, uint[] _coef) onlyOwner {
        if (_source.length != _coef.length) throw;
        recipe.source[_index]     = _source;
        recipe.sourceCoef[_index] = _coef;
    }

    /**
     * @dev Set sink
     * @param _sink is a list of sink tokens
     * @param _coef is a list of sink coeficients
     */
    function setSink(TokenEmission[] _sink, uint[] _coef) onlyOwner {
        if (_sink.length != _coef.length) throw;
        recipe.sink     = _sink;
        recipe.sinkCoef = _coef;
    }

    /**
     * @dev Get source by index 
     * @param _index is a source index
     * @return list of source alternatives and its coeficients
     */
    function getSource(uint _index) constant returns (address[], uint[]) {
        var source = recipe.source[_index];
        address[] memory sourceOut;
        for (uint i = 0; i < source.length; ++i)
            sourceOut[i] = source[i];
        return (sourceOut, recipe.sourceCoef[_index]);
    }

    /**
     * @dev Get sink 
     * @return list of source alternatives and its coeficients
     */
    function getSink() constant returns (address[], uint[]) {
        address[] memory sinkOut;
        for (uint i = 0; i < recipe.sink.length; ++i)
            sinkOut[i] = recipe.sink[i];
        return (sinkOut, recipe.sinkCoef);
    }

    /**
     * @dev Run distillation process
     * @notice Input tokens(any one of alternative) should be approved to this
     */
    function run() {
        TokenEmission token;
        uint value;
        uint i;
        uint j;

        // Take a source tokens
        for (i = 0; i < recipe.source.length; ++i) {
            bool tokenBurned = false;

            // Try to transfer alternatives and burn it
            for (j = 0; j < recipe.source[i].length; ++j) {
                token = recipe.source[i][j];
                value = recipe.sourceCoef[i][j];
                if (token.transferFrom(msg.sender, this, value)) {
                    token.burn(value);
                    tokenBurned = true;
                }
            }

            if (!tokenBurned) throw;
        }

        // Generate sink tokens
        for (i = 0; i < recipe.sink.length; ++i) {
            token = recipe.sink[i];
            value = recipe.sinkCoef[i];
            token.emission(recipe.sinkCoef[i]);
            token.transfer(msg.sender, value);
        }
    }
}
